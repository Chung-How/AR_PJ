<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

<!-- three.js library -->
<script src='../examples/vendor/three.js/build/three.min.js'></script>
<script src="../examples/vendor/three.js/examples/js/libs/stats.min.js"></script>
<!-- ar.js -->
<script src="../build/ar.js"></script>
<script>
    THREEx.ArToolkitContext.baseURL = '../'
    
</script>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
    <div style='position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
        <a href="https://github.com/jeromeetienne/AR.js/" target="_blank">AR.js</a>
        - three.js<br>
        hw4-2
    </div>
    
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.0/jquery.js"></script>
    
    <script>
        // global variables
        var camera, cameraHUD, scene, sceneHUD, renderer;
        var stats;
        var arToolKitSource, arToolKitContext;
        var markerHiro, markerRoot;
        var theta = 0;
        var pos = 0;
        var angle = 0;
        var group;
        var isActive = false;
        var omega = 0;
        var halfH, halfW, whRatio;
        var button;
        var mouse = new THREE.Vector2();
        var raycaster = new THREE.Raycaster();
        var pickables = [];
		var _iOSDevice;
        
        var uvOffsetArray;
        var baseS, baseT;
        var sprite;
        
        class Button {
            constructor(cx, cy, size, colorString = 'yellow', map = null) {
                this.centerX = cx;
                this.centerY = cy;
                this.size = size;
                let material = new THREE.MeshBasicMaterial({
                    color: colorString
                    , transparent: true
                    , opacity: 0.7
                });
                if (map)
                    material.map = map;
                this.mesh = new THREE.Mesh(new THREE.CircleGeometry(size, 32), material);
                this.mesh.position.set(cx, cy, 0);
            }
            setLocation(lx, ly) {
                this.mesh.position.set(lx, ly, 0);
            }
            d2To(v) {
                return Math.sqrt((v[0] - this.centerX) * (v[0] - this.centerX) + (v[1] - this.centerY) * (v[1] - this.centerY));
            }
        }
        
        init();
        animate();
        
        function init() {
            
            var _iOSDevice = !!navigator.platform.match(/iPhone|iPod|iPad|Android/);
            
            if (_iOSDevice) {
                document.addEventListener('touchstart', onTouchStart, false);
                document.addEventListener('touchend', onTouchEnd, false);
                
            } else {
                document.addEventListener('mousedown', onMouseDown, false);
                document.addEventListener('mouseup', onMouseUp, false);
            }
            
            // init renderer
            renderer = new THREE.WebGLRenderer({
                // antialias	: true,
                alpha: true
            });
            renderer.autoClear = false;
            renderer.setClearColor(new THREE.Color('lightgrey'), 0)
            // renderer.setPixelRatio( 1/2 );
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute'
            renderer.domElement.style.top = '0px'
            renderer.domElement.style.left = '0px'
            document.body.appendChild(renderer.domElement);
            
            whRatio = window.innerWidth / window.innerHeight;
            
            stats = new Stats();
            document.body.appendChild(stats.dom);
            
            // init scene and camera
            scene = new THREE.Scene();
            sceneHUD = new THREE.Scene();
            
            halfH = 10;
            halfW = halfH * whRatio;
            
            // Create a BASIC camera
            camera = new THREE.Camera();
            cameraHUD = new THREE.OrthographicCamera(-halfW, halfW, halfH, -halfH, -10, 10);
            scene.add(camera);
            
            ////////////////////////////////////////////////////////////////////////////////
            //          handle arToolkitSource
            ////////////////////////////////////////////////////////////////////////////////
            
            arToolkitSource = new THREEx.ArToolkitSource({
                // to read from the webcam 
                sourceType: 'webcam'
            , })
            
            arToolkitSource.init(function onReady() {
                onResize()
            })
            
            // handle resize
            window.addEventListener('resize', function () {
                onResize()
            })
            
            function onResize() {
                arToolkitSource.onResize()
                arToolkitSource.copySizeTo(renderer.domElement)
                if (arToolkitContext.arController !== null) {
                    arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
                }
            }
            ////////////////////////////////////////////////////////////////////////////////
            //          initialize arToolkitContext
            ////////////////////////////////////////////////////////////////////////////////
            
            arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat'
                , detectionMode: 'mono'
                , maxDetectionRate: 30
                , canvasWidth: 80 * 3
                , canvasHeight: 60 * 3
            , })
            // initialize it
            arToolkitContext.init(function onCompleted() {
                // copy projection matrix to camera
                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
            })
            
            markerHiro = addMarkerHiro();
            scene.add(markerHiro);
			
			// to trigger explosion
            window.addEventListener('mousedown', doMouseDown, false);
            // initialize explosion sprite
            initSprite(markerHiro);
        }
        
        function addMarkerHiro() {
            let markerRootHiro = new THREE.Group();
            
            var artoolkitMarker = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
                type: 'pattern'
                , patternUrl: THREEx.ArToolkitContext.baseURL + '../data/data/patt.hiro'
            })
            
			group = new THREE.Group();
            markerRootHiro.add(group);
			
            // instantiate a loader
            var loader = new THREE.TextureLoader();
            loader.setCrossOrigin('');
            
            // load a resource
            let geometry = new THREE.PlaneGeometry(1, 1);
            let material = new THREE.MeshBasicMaterial();
            let crosshair = new THREE.Mesh(geometry, material);
            crosshair.rotation.x = -Math.PI / 2;
            loader.load(
                'https://i.imgur.com/czAPVT8.png'
                , function (texture) {
                    crosshair.material = new THREE.MeshBasicMaterial({
                        map: texture
                    });
                    crosshair.material.transparent = true;
                }
            );
            group.add(crosshair);
            
            return markerRootHiro;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            stats.update();
            
            if (arToolkitSource.ready === false) return
            arToolkitContext.update(arToolkitSource.domElement)
            
            renderer.clear();
            renderer.render(scene, camera);
            button.mesh.material.visible = markerRoot.visible;
			
            let localCamera = markerHiro.worldToLocal(new THREE.Vector3(0, 0, 0))
            
            let point = new THREE.Vector3(0, 0, 1);
            let angle = point.angleTo(localCamera);
            let axis = new THREE.Vector3();
            axis.crossVectors(point, localCamera).normalize(); // normalization is IMPORTANT!
            sprite.quaternion.setFromAxisAngle(axis, angle);
            
            renderer.render(scene, camera);
            renderer.render(sceneHUD, cameraHUD);
        }
        
        function clamp(x, xLo, xHi) {
            if (x < xLo) return xLo;
            if (x > xHi) return xHi;
            else return x;
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            
            var touches = event.changedTouches;
            for (var i = 0; i < touches.length; i++) {
                
                mouse.x = (touches[i].pageX / window.innerWidth) * 2 - 1;
                mouse.y = -(touches[i].pageY / window.innerHeight) * 2 + 1;
                
                // find intersections (only pick the HUD scene, using OrthographicCamera)  		
                raycaster.setFromCamera(mouse, cameraHUD);
                
                var intersects = raycaster.intersectObjects(pickables);
                
                if (intersects.length > 0) {
                    $('#press')
                        .css('color', 'yellow');
                    $('#press')
                        .html('<p id="press" style ="color:white;text-align:center;">press</p>');
                    isActive = true;
                }
            }
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
            
            var touches = event.changedTouches;
            for (var i = 0; i < touches.length; i++) {
                $('#press')
                    .css('color', 'cyan');
                $('#press')
                    .html('<p id="press" style ="color:white;text-align:center;">did not press</p>');
                isActive = false;
            }
        }
        
        function onMouseDown(event) {
            event.preventDefault();
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // find intersections (only pick the HUD scene, using OrthographicCamera)  		
            raycaster.setFromCamera(mouse, cameraHUD);
            
            var intersects = raycaster.intersectObjects(pickables);
            
            if (intersects.length > 0) {
                $('#press')
                    .css('color', 'yellow');
                $('#press')
                    .html('<p id="press" style ="color:white;text-align:center;">press</p>');
                isActive = true;
            }
        }
        
        function onMouseUp(event) {
            event.preventDefault();
            
            $('#press')
                .css('color', 'cyan');
            $('#press')
                .html('<p id="press" style ="color:white;text-align:center;">did not press</p>');
            isActive = false;
            
        }
        
        function buildSprite(texMat, markerGroup) {
            const size = 2.0;
            
            // old school ...
            let vertices = [-size / 2, -size / 2, 0, size / 2, -size / 2, 0
                    , size / 2, size / 2, 0, -size / 2, size / 2, 0];
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            let indices = [0, 1, 2, 0, 2, 3];
            geometry.setIndex(indices);
            
            let uvs = []
            uvs.push(0, 0.75, 0.125, 0.75, 0.125, 1, 0, 1); // LL of first frame: [0, 0.75]
            geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            
            geometry.computeBoundingSphere();
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();
            
            sprite = new THREE.Mesh(geometry, texMat);
            markerGroup.add(sprite);
        }
        
        function initSprite(markerGroup) {
            setUpOffsetArray();
            
            // instantiate a loader
            var loader = new THREE.TextureLoader();
            loader.setCrossOrigin('');
            // load a resource
            loader.load(
                // resource URL
                'https://i.imgur.com/6ePTx6p.png',
                
                // Function when resource is loaded
                function (texture) {
                    // Plane with default texture coordinates [0,1]x[0,1]
                    var texMat = new THREE.MeshBasicMaterial({
                        map: texture
                        , transparent: true, // cutout texture: set transparent: true
                        side: THREE.DoubleSide
                    });
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    buildSprite(texMat, markerGroup);
                },
                // Function called when download progresses
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // Function called when download errors
                function (xhr) {
                    console.log('An error happened');
                }
            );
            
        }
        
        
        // slightly different
        // this is an OFFSET array
        // how the array going to increment in this state 
        // initial uv (of lower left corner) is (0, 0.75)
        function setUpOffsetArray() {
            uvOffsetArray = [];
            var rowCount = 4; // 4x8 sprites
            var colCount = 8;
            for (var i = 0; i < rowCount; i++) {
                var row = [];
                for (var j = 0; j < colCount; j++)
                    row.push(new THREE.Vector2(j * 0.125, -0.25 * i));
                uvOffsetArray.push(row);
            }
        }
        
        function _spriteAnimate() {
            let msg = `[${baseS}] [${baseT}]`
            console.log(msg);
            
            sprite.material.map.offset.copy(uvOffsetArray[baseS][baseT]);
            baseT = (baseT + 1) % 8;
            if (baseT === 0) {
                baseS = (baseS + 1) % 4;
            }
            
            if (baseS !== 3 || baseT !== 7) // NOT (baseS = 3 ^ baseT = 7)
                setTimeout(_spriteAnimate, 100); // proceed to next frame
            else {
                sprite.material.map.offset.copy(uvOffsetArray[0][0]); // back to first frame
            }
        }
        
        // trigger the animation
        function spriteAnimate() {
            if (sprite === undefined) {
                console.log('return in spriteAnimate')
                return;
            }
            
            baseS = baseT = 0;
            setTimeout(_spriteAnimate, 100);
        }
        
    </script>
</body>
